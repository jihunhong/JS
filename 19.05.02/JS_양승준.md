# JS STUDY 0430
----
#### Chapter 9 - 클래스와 모듈
###### 서론
* 객체는 다른 모든 객체와 구분되는 프로퍼티의 고유한 집합이다.
  그러나 객체끼리 특정 프로퍼티를 공유할 수 있도록 클래스를 정의하는 것도 종종 유용하다.
  클래스의 구성원, 인스턴스는 상태를 정의하거나 저장하는 프로퍼티를 가지고 있고, 그들의 동작을 정의하는 프로퍼티`(=메서드)`를 가지고 있기도 한다.
  자바스크립트에서 클래스는 `프로토타입 기반의 상속 메커니즘`을 기반으로 하고 있다. 두 객체가 같은 프로토타입 객체로부터 프로퍼티를 상속받았다면, 둘은 같은 클래스의 인스턴스다.

* 프로토타입에 대해서
  * 자바스크립트의 큰 특징중 하나는 자바스크립트는 프로토타입 기반이라는 것이다.


    ![프로토타입 사진1](https://i.imgur.com/bsTllOJ.png)
    자바스크립트에서 함수를 선언하면 `함수 객체`와 `함수 Prototype Object` 두개의 객체가 생성된다.


###### 9.1 클래스와 프로토타입
* 자바스크립트의 클래스는 `같은 프로토타입 객체`로부터 `프로퍼티를 상속`받은 객체의 집합이다.
  **아래는 클래스를 정의하는 한 방법이다(생성자 없는 관용적이진 않은 방법)**
  ```js
  function range(from, to){
    //아래에 정의한 range.methods 프로토타입 객체를 상속하는 객체를 생성하기 위해
    //inherit() 함수를 사용한다.
    //range.methods 프로토타입 객체는 이 함수의 프로퍼티로 저장되고 모든 range 객체가 공유하는 메서드를 정의
    var r = inherit(range.methods);
    r.from = from;
    r.to = to;
    //위의 프로퍼티 들은 해당 객체의 고유한 값이고 상속되지 안흔다.
    return r;
  }

  range.methods={//이 프로토타입 객체는 모든 range 객체가 상속하는 메서드를 정의한다.
    includes: function(x){return ~~~~;}
    foreach: function(f){
      for(var x = Math.ceil(this.from); x<= this.to; x++)
        f(x);
    }
  }

  var r = range(1,3);
  r.includes(2);
  r.foreach(console.log);
  ```
  >주목할 만한 점은 range() 함수는 각 range 객체에 from 프로퍼티와 to 프로퍼티를 정의하고 있다.
  이 프로퍼티들은 각 range 객체의 고유한 상태를 저장하고, 공유되거나 상속되지 안흔다.
  마지막으로 range.methods의 모든 메서드는 상속되고 공유되며 fro,to 프로퍼티를 참조하기 위해서 this를 사용해 접근한다.
  this는 메서드의 호출 대상 객체를 가리킨다.

###### 9.2 클래스와 생성자
* 생성자는 new 키워드를 사용하여 호출된다. 생성자를 호출하면 자동으로 새로운 객체가 생성되고, 생성자 함수 내부에서 새로 생성된 객체를 사용하기때문에, 생성자 함수는 새 객체의 상태를 초기화하는 데만 신경 쓰면 된다.생성자 호출의 `핵심적인 특징`은 생성자의 프로토타입 프로퍼티가 새 객체의 프로토타입으로 사용된다는 것이다.한 생성자를 통해 생성된 모든 객체는 같은 객체를 상속하고, 따라서 같은 클래스의 멤버임을 뜻한다.
```js
function Range(from, to){

  //이 함수는 새 Range 객체를 초기화하는 생성자 함수이다.
  //이 함수는 어떤 객체도 내부에서 생성하고 반환하지 않고 단지 this를 초기화한다.
  this.from = from;
  this.to = to;
  //위의 프로퍼티 들은 해당 객체의 고유한 값이고 상속되지 안흔다.
}

range.methods={//이 프로토타입 객체는 모든 range 객체가 상속하는 메서드를 정의한다.
  includes: function(x){return ~~~~;}
  foreach: function(f){
    for(var x = Math.ceil(this.from); x<= this.to; x++)
      f(x);
  }
}

var r = new Range(1,3);
r.includes(2);
r.foreach(console.log);
```
클래스와 생성자 함수의 이름을 대문자로 시작하는 것은 매우 일반적인 코딩 규칙이다. 일반 함수와 메서드는 소문자로 이름을 시작한다.
**밑은 팩터리 함수와 Range() 생성자와의 다른점이다.**
  * 위의 range() 팩터리 함수가 일반 함수처럼 호출되는 반면 Range() 생성자는 new 키워드를 사용하여 호출된다.
  * range() 팩터리 함수의 프로토타입은 range.methods이고 `임의적`이다.
  Range() 생성자의 프로토타입은 Range.prototype 이고 `정해진 규칙` 이다. Range() 생성자를 호출하면 자동으로 Range.prototype이 새로 생성된 Range 객체의 프로토 타입으로 지정된다.

###### 9.2.1 생성자와 클래스 구별
* 프로토타입 객체는 클래스를 구별할 때 핵심적인 역할을 한다. 두 객체는 같은 같은 프로토타입 객체를 상속한 경우에만 같은 클래스의 인스턴스다.
새로 생성된 객체의 상태를 초기화하는 생성자 함수는 클래스 구별의 핵심이 아니다.
서로 다른 두 생성자 함수라도 같은 프로토타입 객체를 가리키는 prototype 프로퍼티를 가질 수 있다.
`r instanceof Range` -> r이 Range.prototype을 상속했을때 true를 반환한다.

###### 9.3 자바 스타일 클래스
* 객체 지향 언어에 다음의 4가지 멤버 유형이 있다.
`인스턴스 필드` -> 개별 객체의 상태를 저장한다.  
`인스턴스 메서드` -> 클래스의 모든 인스턴스가 공유하는 메서드로 개별 인스턴스를 대상으로 호출됨
`클래스 필드` -> 인스턴스가 아니라 클래스와 관련된 프로퍼티나 변수
`클래스 메서드` -> 인스턴스가 아니라 클래스와 관련된 메서드
js와 자바와 다른 점 한가지는 함수가 값이라는 점이고, 따라서 메서드와 필드 사이에는 뚜렷한 구분이 없다.
만약 프로퍼티 값이 함수라면 그 프로퍼티는 메서드이고 함수가 아니라면 보통의 프로퍼티나 필드일 뿐이다.
객체 지향 언어의 4가지 유형을 JS에서 따라할 수 있다. js로 클래스를 정의할 때는 세가지 객체가 관련된다.
그리고 이 세 객체의 프로퍼티는 각각 다른 종류의 멤버 구실을 한다.
`생성자 객체` -> 생성자 함수(객체)는 클래스 이름을 정의한다.이 생성자 객체에 추가한 프로퍼티는 클래스 필드와 클래스 메서드이다.
`프로토타입 객체` -> 이 객체의 프로퍼티는 클래스의 모든 인스턴스에 상속된다. 그 값이 함수일 경우 인스턴스 메서드로 동작한다.
`인스턴스 객체` ->각 인스턴스는 독립적이고 인스턴스에 직접 정의한 프로퍼티는 다른 인스턴스에 공유되지 않는다. 함수가 아닌 프로퍼티는 클래스의 인스턴스 필드로 작동한다.

* js에서 클래스를 정의하는 과정은 세 단계의 알고리즘으로 줄일 수 있다.
  * 1. 새 객체의 인스턴스 프로퍼티를 설정하는 생성자 함수를 작성한다.
  * 2. 생성자의 프로토타입 객체에 인스턴스 메서드를 정의한다.
  * 3. 생성자 자체에 클래스 필드와 클래스 프로퍼티를 정의한다.

    >이 규칙으로 간단히 definceClass() 함수로 구현할 수 있다. 255p 밑 참조

* 자바에서 지원하지만 js에서 지원하지 않는 것들
  * 자바는 인스턴스 메서드 안에서 인스턴스 필드를 메서드의 지역 변수처럼 사용할 수 있고 , 어떤 접수다도 붙이 필요 없지만 js는 지원하지않음 (with 사용하면되지만 권장하진않음;;)
  * 자바에서는 `final`을 사용하여 상수 필드를 정의할 수 있다. 그리고 `private`또한 있는데 이런 키워드 들이 자바스크립트에는 없어서 `힌트를 제공하는 표기 규칙`을 사용한다.
  * `private` 프로퍼티는 `클로저`의 `지역변수`로 흉내 낼 수 있다.

###### 9.4 클래스 확장하기

* js의 프로토타입 기반 상속 메커니즘은 동적이다. 객체는 자신의 프로토타입에서 프로퍼티를 상속받는데, 객체가 생성된 이후에 프로토타입이 변경되더라도 마찬가지이다.
**자바스크립트 객체의 프로토타입에 메서드를 추가함으로써 간단히 js 클래스를 확장 할수있따**

```js
function Complex(a,b){} // 이런 함수가 있다면
Complex.prototype.conj = function(){
  return new Complex(1,3); // 이렇게 추가해서 확장가능. 왜그런지는 잘..
}
```

**Object.prototype에도 메서드를 추가할 수 있고, 그러면 모든 객체에서 추가 된 메서드를 사용이 가능하다.**
하지만 권장하진 않음;; ecmascript5 이전 버전에서는 추가 메서드가 열거되지 않게 할 방법이 없기 때문에.

###### 9.5 클래스와 자료형
* js에서는 불리언,숫자 등 몇 안되는 자료형을 typeof연산자를 사용하면 이러한 형식을 구분할 수 있다. `그러나 일반적으로 클래스는 독자적인 자료형으로 다루는 것이 편하고` 클래스를 기준으로 객체를 구분하는 것이 편리하다.
객체의 클래스를 판단하는 세가지 기법인 `instanceof 연산자` , `constructor 프로퍼티` , `생성자 함수 이름` 이 세가지 기법중 어떤것도 만족스럽진 않고;; `덕 타이핑`의 논의로 끝난다. `덕 타이핑`은 객체의 클래스가 무엇인지보다는 객체가 무엇을 하느냐(어떤 메서드를 가지고 있는지에)에 더 중점을 두는 프로그래밍 철학이다.

어떤 객체의 클래스를 구별하는 방법.
* instanceof 연산자
 왼쪽 피연산자는 클래스를 판별하려는 객체, 오른쪽 피연산자는 생성자 함수(곧 해당클래스의 이름)
 `o instanceof c` o가 c.prototype을 상속했을때 `true` 반환
 단점 -> 어떤 객체의 클래스가 무엇인지 알아내는데 사용 불가능
* constructor 프로퍼티(261p 참조)
  생성자로 클래스를 구별하는 방법이다.
* instanceof와 constructor의 문제는 여러 실행 컨텍스트가 존재하고, 따라서 생성자함수의 사본이 여러 개 존재하는 상황에서 나타날 수있다. 이 방법은 `클래스 식별자`로 생성자 함수 대신 `그 이름을 사용`하는 것이다.
name프로퍼티가 없는 js 구현체에서는, 함수를 문자열로 변환한 다음에 이름을 추출해 낼수 있다.
* 덕 타이핑
 `이 객체의 클래스가 무엇인가` 가 아니라 `이 객체가 무엇을 할 수 있는가` 를 묻는방법이다.


###### 9.6 자바스크립트의 객체 지향 기법
* 자바스크립트 클래스 프로그래밍에 대한 실용적 기법들을 다룬다.

* 9.6.1 set 클래스(267p)
  중복되지 않은 값을 정렬되지 않은 형태로 저장하는 데이터 구조
  자바스크립트의 객체는 기본적으로 프로퍼티 이름으로 이루어진 집합이다. 객체를 문자열의 집합으로 사용하는 것은 대수롭지 않은 일이다.

* 9.6.2 열거형
  나열될 수 있는 유한 개의 값 집합을 사용하여 정의하는 자료형이다.`enum` 키워드 생각하면됨.
  자바스크립트엔 enum이 예약어로 있긴 하지만 사용되지 않는데 언젠가 지원될 가능성이 있다고 생각된다. 아직 없기때문에 열거형을 정의하여 사용해야한다.

* 9.6.3 표준변환메서드
  메서드들이 형 변환이 필요할때 자동으로 호출되는것처럼 클래스에 변환 메서드를 구현하는것은 굉장히 중요하다.
  `toString`,`toLocaleString`,`valueOf`등이 있다

* 9.6.4 비교 메서드
  * 자바스크립트의 동치 연산자들은 객체를 비교할 때, 값이 아니라 참조를 사용한다.
  즉 주어진 두 참조가 같은 객체를 가리키고 있는지를 살펴본다.
  이런 연산자들은 두 객체에, 이름이 같고 값도 같은 프로퍼티가 존재하는지를 검사하지 안흔ㄴ다. 두 객체가 동등한지 또는 어느 한쪽이 더 크거나 작은지를 비교할 수 있게 만드는 것도 유용하다.
  자신이 클래스를 정의하고 이 클래스의 인스턴스를 서로 비교하려면 `비교하는데 사용할 메서드`를 정의해야한다.
  인스턴스를 동등 비교하려면 equals 인스턴스 메서드를 정의해야한다.

###### 9.7 서브클래스
* 객체 지향 프로그래밍에서 클래스 B는 다른 클래스 A를 확장하거나 클래스 A의 하위클래스가 될 수 있다. 이런 경우, 클래스 A를 `슈퍼클래스`라고 하고 클래스 B를 `서브클래스`라고 한다. 클래스 B의 인스턴스는 클래스 A의 모든 인스턴스 메서드를 상속한다.
클래스 B의 메서드가 클래스 A의 메서드를 재정의 했을때 클래스 B의 재정의된 메서드에서 클래스 A의 원래 메서드를 호출할 수가 있는데 이를 `메서드 체이닝` 이라고 한다.
비슷하게 서브클래스의 생성자 B()가 슈퍼클래스의 생성자A()를 호출할 필요가 있는데, 이는 `생성자 체이닝`이라고 한다.
