# JS STUDY 0430
----
#### Chapter 9 - 클래스와 모듈
###### 서론
* 객체는 다른 모든 객체와 구분되는 프로퍼티의 고유한 집합이다.
  그러나 객체끼리 특정 프로퍼티를 공유할 수 있도록 클래스를 정의하는 것도 종종 유용하다.
  클래스의 구성원, 인스턴스는 상태를 정의하거나 저장하는 프로퍼티를 가지고 있고, 그들의 동작을 정의하는 프로퍼티`(=메서드)`를 가지고 있기도 한다.
  자바스크립트에서 클래스는 `프로토타입 기반의 상속 메커니즘`을 기반으로 하고 있다. 두 객체가 같은 프로토타입 객체로부터 프로퍼티를 상속받았다면, 둘은 같은 클래스의 인스턴스다.

###### 9.1 클래스와 프로토타입
* 자바스크립트의 클래스는 `같은 프로토타입 객체`로부터 `프로퍼티를 상속`받은 객체의 집합이다.
  **아래는 클래스를 정의하는 한 방법이다(생성자 없는 관용적이진 않은 방법)**
  ```js
  function range(from, to){
    //아래에 정의한 range.methods 프로토타입 객체를 상속하는 객체를 생성하기 위해
    //inherit() 함수를 사용한다.
    //range.methods 프로토타입 객체는 이 함수의 프로퍼티로 저장되고 모든 range 객체가 공유하는 메서드를 정의
    var r = inherit(range.methods);
    r.from = from;
    r.to = to;
    //위의 프로퍼티 들은 해당 객체의 고유한 값이고 상속되지 안흔다.
    return r;
  }

  range.methods={//이 프로토타입 객체는 모든 range 객체가 상속하는 메서드를 정의한다.
    includes: function(x){return ~~~~;}
    foreach: function(f){
      for(var x = Math.ceil(this.from); x<= this.to; x++)
        f(x);
    }
  }

  var r = range(1,3);
  r.includes(2);
  r.foreach(console.log);
  ```
  >주목할 만한 점은 range() 함수는 각 range 객체에 from 프로퍼티와 to 프로퍼티를 정의하고 있다.
  이 프로퍼티들은 각 range 객체의 고유한 상태를 저장하고, 공유되거나 상속되지 안흔다.
  마지막으로 range.methods의 모든 메서드는 상속되고 공유되며 fro,to 프로퍼티를 참조하기 위해서 this를 사용해 접근한다.
  this는 메서드의 호출 대상 객체를 가리킨다.

###### 9.2 클래스와 생성자
* 생성자는 new 키워드를 사용하여 호출된다. 생성자를 호출하면 자동으로 새로운 객체가 생성되고, 생성자 함수 내부에서 새로 생성된 객체를 사용하기때문에, 생성자 함수는 새 객체의 상태를 초기화하는 데만 신경 쓰면 된다.생성자 호출의 `핵심적인 특징`은 생성자의 프로토타입 프로퍼티가 새 객체의 프로토타입으로 사용된다는 것이다.한 생성자를 통해 생성된 모든 객체는 같은 객체를 상속하고, 따라서 같은 클래스의 멤버임을 뜻한다.
```js
function Range(from, to){

  //이 함수는 새 Range 객체를 초기화하는 생성자 함수이다.
  //이 함수는 어떤 객체도 내부에서 생성하고 반환하지 않고 단지 this를 초기화한다.
  this.from = from;
  this.to = to;
  //위의 프로퍼티 들은 해당 객체의 고유한 값이고 상속되지 안흔다.
}

range.methods={//이 프로토타입 객체는 모든 range 객체가 상속하는 메서드를 정의한다.
  includes: function(x){return ~~~~;}
  foreach: function(f){
    for(var x = Math.ceil(this.from); x<= this.to; x++)
      f(x);
  }
}

var r = new Range(1,3);
r.includes(2);
r.foreach(console.log);
```
클래스와 생성자 함수의 이름을 대문자로 시작하는 것은 매우 일
반적인 코딩 규칙이다. 일반 함수와 메서드는 소문자로 이름을 시작한다. 밑은 팩터리 함수와 Range() 생성자와의 다른점이다.
  * 위의 range() 팩터리 함수가 일반 함수처럼 호출되는 반면 Range() 생성자는 new 키워드를 사용하여 호출된다.
  * range() 팩터리 함수의 프로토타입은 range.methods이고 `임의적`이다.
  Range() 생성자의 프로토타입은 Range.prototype 이고 `정해진 규칙` 이다.

###### 9.2.2 constructor 프로퍼티(같이 보기 요망)

###### 9.3 자바 스타일 클래스
* js와 자바와 다른 점 한가지는 함수가 값이라는 점이고, 따라서 메서드와 필드 사이에는 뚜렷한 구분이 없다.
만약 프로퍼티 값이 함수라면 그 프로퍼티는 메서드이고 함수가 아니라면 보통의 프로퍼티나 필드일 뿐이다.
자바에서는 `final`을 사용하여 상수 필드를 정의할 수 있다. 그리고 `private`또한 있는데 이런 키워드 들이 자바스크립트에는 없어서 `힌트를 제공하는 표기 규칙`을 사용한다.
`private` 프로퍼티는 `클로저`의 `지역변수`로 흉내 낼 수 있다.

###### 9.6 자바스크립트의 객체 지향 기법
* 자바스크립트 클래스 프로그래밍에 대한 실용적 기법들을 다룬다.

* 9.6.4 비교 메서드
  * 자바스크립트의 동치 연산자들은 객체를 비교할 때, 값이 아니라 참조를 사용한다.
  즉 주어진 두 참조가 같은 객체를 가리키고 있는지를 살펴본다.
  이런 연산자들은 두 객체에, 이름이 같고 값도 같은 프로퍼티가 존재하는지를 검사하지 안흔ㄴ다. 두 객체가 동등한지 또는 어느 한쪽이 더 크거나 작은지를 비교할 수 있게 만드는 것도 유용하다.
  자신이 클래스를 정의하고 이 클래스의 인스턴스를 서로 비교하려면 `비교하는데 사용할 메서드`를 정의해야한다.

###### 9.7 서브클래스
* 객체 지향 프로그래밍에서 클래스 B는 다른 클래스 A를 확장하거나 클래스 A의 하위클래스가 될 수 있다. 이런 경우, 클래스 A를 `슈퍼클래스`라고 하고 클래스 B를 `서브클래스`라고 한다. 클래스 B의 인스턴스는 클래스 A의 모든 인스턴스 메서드를 상속한다.
클래스 B의 메서드가 클래스 A의 메서드를 재정의 했을때 클래스 B의 재정의된 메서드에서 클래스 A의 원래 메서드를 호출할 수가 있는데 이를 `메서드 체이닝` 이라고 한다.
비슷하게 서브클래스의 생성자 B()가 슈퍼클래스의 생성자A()를 호출할 필요가 있는데, 이는 `생성자 체이닝`이라고 한다.
